

//////////////////////ORIGINAL CUDA Code (mvt)////////////////////


for(int i=0; i<n; ++i)
  kernel_x1<<<1, blockDim>>>(n, i, x, y, A);


__global__ void kernel_x1(int n, int i,
                          double *x,
                          double *y,
                          double *A) {
  int j = threadIdx.x;
  double dot = 0.0;
  if (j < n) {
      x1[j] += A[j * n + i] * y[i];
    double dot = x[j];
  }
}


/////////////////TULIP Execution Model Change///////////////

for(int i=0; i<n; ++i){
  //DOALL PARALLELISM
  for(int j=0; j<blockDim; ++j){
    if(j<n){
      x1[j] += A[j * n + i] * y[i];
    }
  }
}

//////////////TULIP + NOELLE Optimization/////////
//DOALL WITH REDUCTION 
for(int i=0; i<n; ++i){
  //DOALL
  for(int j=0; j<blockDim; ++j){
    if(j<n){
      x[j] += A[j * n + i] * y[i];
    }
  }
}

///////////////TULIP CodeGen////////////////////
//DOALL REDUCTION
for(int i=0; i<n; ++i){
  //DOALL Parallelism
  #pragma omp parallel for
  //or #pragma omp target distribute teams parallel for map (...)
  for(int j=0; j<blockDim; ++j){
    if(j<n){
      x1[j] += A[j * n + i] * y[i];
    }
  }
}

///////////////Programmer: Loop Interchange/////////////////////////

#pragma omp parallel for
#pragma omp target distribute teams parallel for map (...)
for(int i=0; i<n; ++i){
  for(int j=0; j<n; ++j){
    x1[i] += A[i * n + j] * y[j];
  }
}
